






Proyecto: Sistema de asistencia para ganar partidas de poker en salas de juego online.

Es muy importante que no ignores ningun parametro.

Quiero que construyas un programa completamente funcional dedicado exclusivamente al an√°lisis visual pasivo de una mesa de p√≥ker que se muestra en mi monitor para determinar siempre la mejor jugada posible con todos los parametros mencionados. El programa construido en Python se llamara "HTP" High Tech Player,  El uso de las librerias incluidas es orientativo y puede ser modificado, actualizado segun sea conveniente. 

El principal objetivo del programa es analizar el juego para determinar la mejor via de accion posible para el jugador en todo momento teniendo en cuenta las probabilidades y estadisticas en el juego y las cartas comunitarias, cartas propias, tama√±o de apuesta actuales de cada jugador, tama√±o del bote (pot) y stacks visibles. Todo debe hacerse evadiendo cualquier tipo de deteccion que las salas de poker. 


El programa debe cumplir con estas condiciones.

Aclaraciones importantes:

‚ÄúTodo el c√≥digo de ejemplo de bucles while True con camera.get_latest_frame(), model(frame) y env√≠o directo a WebSocket son versiones hist√≥ricas y NO se usar√°n en la versi√≥n final. La versi√≥n final debe seguir estrictamente la arquitectura de plugins y SharedState descrita en htp.py.‚Äù 

Cualquier error propio de de sintaxis o conflictos debe ser reparado y correjido de la mejor manera posible.

Las m√∫ltiples versiones de ejemplo son ‚Äúvariantes‚Äù y que se tomar√°n como referencia para implementar una s√≥la versi√≥n unificada.

Todos los bloques leer_dinero_robusto/buffer_ocr deberan aplicarse bajo la secci√≥n de "advanced_ocr_plugin.py".

‚ÄúEl detector se entrenar√° con Ultralytics (YOLOv11), pero se usar√° un export a OpenVINO.

config.json tendr√° una clave yolo_model_path apuntando a la carpeta donde est√°n best.xml y best.bin de OpenVINO.
vision_core.py debe leer esa ruta desde config y cargar el modelo usando la API adecuada.‚Äù




1. Funci√≥n principal del programa



Identificar autom√°ticamente la ventana del cliente de p√≥ker (puede ser por ejemplo por t√≠tulo, clase, OCR de ventana, heur√≠stica visual, etc. o tecnicas hibridas) con libreria OpenCV entre otras, a√∫n cuando esta se mueva durante el juego. Para hacer esto utilizar tambien coordenadas visuales de orientacion de los parametros necesarios.

Determinar siempre las probabilidades de ganar apostando, haciendo check o fold.

Captura optimizada con multi-hilo y buffering para la mas baja latencia posible.

Detect and track of the client window of poker in real-time using hybrid methods (window API + OCR fallback), adapting to window moves.

Actualizar un panel o ventana propia con toda la informaci√≥n detectada.

Integraci√≥n de visi√≥n computacional con aprendizaje profundo para detecci√≥n y clasificaci√≥n precisa de cartas y s√≠mbolos y demas datos pertinente ya sean imagenes o texto.

Configuraci√≥n din√°mica con interfaz gr√°fica para calibraci√≥n visual y ajuste de regiones.

Identificar a los oponentes de manera fehaciente para aplicar Tecnicas "Anti-Bluff" y otros mecanismos para maximizar el rendimiento del analisis del juego.

Imprimir de forma dinamica en todo momento el mejor curso de accion posible para ganar el juego. El Equity el el Dato Psicol√≥gico del rival.

Ensure minimal resource usage, stability even under window loss or movement, and automatic scaling to the detected window size.

El usuario debe tener la opcion dentro del GUI de seleccionar la ventana donde esta la mesa de poker que se quiere analizar.

El sotware debe tener una opcion donde se pueda ver el ultimo screenshot tomado, para asi comprobar que todo este funcionando correctamente.

El software debe tener una estructura modular y extensible: tiene interfaces de plugin para m√≥dulos de captura, procesamiento y an√°lisis, de modo que m√°s tarde puedas reemplazar/a√±adir m√≥dulos (por ejemplo, un m√≥dulo de captura distinto), es decir debe utiliz√°r una estructura basada en plugins o carga din√°mica de m√≥dulos para lograr que el programa sea escalable, permita agregar nuevas funciones y no requiera modificar el archivo principal.


El sistema completo, desde la visi√≥n hasta la sugerencia de la jugada, se puede dividir en tres capas, y las dos √∫ltimas capas (las que realizan el an√°lisis estrat√©gico) dependen directamente de estas tecnolog√≠as:

A) Detecci√≥n y Reconocimiento (Visi√≥n)
Tecnolog√≠a: Deep Learning (DL), espec√≠ficamente YOLO (Redes Neuronales Convolucionales o CNN).

Funci√≥n Estrat√©gica: Este m√≥dulo no analiza la estrategia en s√≠, sino que proporciona los datos de entrada (el estado del juego) al motor estrat√©gico. Identifica qu√© cartas hay, cu√°nto dinero hay en el bote y en las apuestas, y qu√© posiciones est√°n ocupadas. Sin esta base de datos precisa, no puede haber an√°lisis estrat√©gico.

B) Motor de Evaluaci√≥n de Manos:

La Estrategia Pre-Flop: "Tablas JSON" (Lookup Tables).

La Estrategia Post-Flop: El "Solver Ligero" Aqu√≠ es donde usamos eval7 para simular ser un Solver.

Para que eval7 funcione como un Solver, necesitas definir Rangos de Oponentes.

Tecnolog√≠a: Matem√°ticas puras (Combinatoria y Probabilidad) complementadas con ML/DL en sistemas avanzados.

Funci√≥n Estrat√©gica: Calcula las probabilidades directas (Equity) de ganar o empatar la mano. Y la calificacion psicologica.

Enfoque Cl√°sico (No ML): Utiliza librer√≠as como PokerKit o eval7 para calcular la fuerza de la mano seg√∫n reglas fijas.

Enfoque Avanzado (ML): Los modelos de ML pueden utilizarse para estimar la mano del oponente bas√°ndose en sus patrones de apuesta hist√≥ricos (Range Estimation), lo que hace que el c√°lculo de Equity sea mucho m√°s preciso y estrat√©gico.



C) Agente de Decisi√≥n (An√°lisis Estrat√©gico)

Funci√≥n Estrat√©gica: Este es el verdadero an√°lisis estrat√©gico. Utiliza modelos entrenados para:

GTO (Game Theory Optimal) y algoritmos CFR (Counterfactual Regret Minimization) son entrenados para encontrar la estrategia de equilibrio (GTO).

Sugerencia de Jugada: Bas√°ndose en el estado del juego el modelo sugiere la acci√≥n √≥ptima (Fold, Call, Raise) para maximizar el valor esperado (EV) a largo plazo.




2. Herramientas clave:

Se utiliza la librer√≠a Ultralytics (que implementa YOLOv11) combinada con OpenCV y Computer Vision entre otras posibilidades para extraer: Cartas comunitarias, cartas propias, tama√±os de apuesta actuales, tama√±o del bote (pot), stacks visibles, texto relevante en la interfaz.

Se utiliza como base principal de reconocimiento las librerias YOLOv11 pre entrenada + OpenCV.

Se utiliza OpenCV tambien para tareas de visi√≥n por computadora como la detecci√≥n de contornos, la correcci√≥n de perspectiva y el preprocesamiento de im√°genes (filtrado, umbralizaci√≥n, etc.).

Se utiliza captura de Escritorio (Desktop Duplication API): En lugar de intentar capturar una ventana espec√≠fica, se puede utilizar la Desktop Duplication API de Windows. Esta API se dise√±√≥ para la duplicaci√≥n de escritorio (ej. para streaming o proyectores) y tiene un nivel de privilegio m√°s alto, a menudo eludiendo las restricciones de captura de ventana individuales, es decir una vez que se obtiene el frame del escritorio, se usa OpenCV/YOLO para recortar solo la parte que corresponde a la ventana del juego (utilizando las coordenadas obtenidas de tu sistema de calibraci√≥n avanzado).

Se utiliza la libreria PokerKit y eval7 para l√≥gica de juego, simulaciones y evaluaci√≥n de manos de alta velocidad para la mayor√≠a de variantes de p√≥ker.

Adem√°s de la probabilidad se requiere un motor que sugiera la acci√≥n √≥ptima (CALL, RAISE, FOLD) bas√°ndose en la Teor√≠a de Juegos √ìptima (GTO) y otros metodos detallados.






3. Funciones Stealth:

Nombres inocuos, reducci√≥n de logs, evitar patrones muy obvios, minimizar llamadas sospechosas, etc.

Evasi√≥n de Detecci√≥n Est√°tica (An√°lisis de C√≥digo):

Para evitar ser identificado por scanners de firmas o an√°lisis de c√≥digo fuente/binario:

Ofuscaci√≥n del C√≥digo:

Empaquetamiento (Packing) y Carga de M√≥dulos:

Compresi√≥n/Empaquetamiento: Utilizar empaquetadores (como UPX o versiones ofuscadas) para comprimir el c√≥digo ejecutable, lo que dificulta el an√°lisis est√°tico.

Carga de M√≥dulos en Tiempo de Ejecuci√≥n: Evitar enlazar din√°micamente con librer√≠as (DLLs) comunes del OS. En su lugar, el software resuelve las direcciones de las funciones necesarias (por ejemplo, funciones del Kernel32.dll) manualmente en tiempo de ejecuci√≥n, carg√°ndolas en memoria de forma din√°mica.

Patrones de captura configurables (para no saturar la m√°quina).




4. Problemas recurrentes:

El problema fundamental es que GGPoker usa renderizado protegido que impide la captura directa.

Anti-scraping

Detectan herramientas que intentan:

Leer la ventana por API est√°ndar

Usar OCR en tiempo real

Capturar FPS muy altos

Abrir handles con permisos inusuales

Windows permite a las apps saber si otros procesos abrieron su ventana con ciertas flags.

Proyectos de c√≥digo abierto y discusiones de desarrollo (ej. Chromium) muestran que la conducta del compositor y del pipeline de overlays puede cambiar din√°micamente (p. ej. ‚Äúsaltar overlays‚Äù cuando se detecta captura), y esas decisiones pueden introducir condiciones de degradaci√≥n que hay que tratar en tu l√≥gica de ataque.







5. Caracteristicas tecnicas clave:

Variaciones anti-patr√≥n:
Peque√±as variaciones en coordenadas de captura
Timing de ejecuci√≥n impredecible
Preprocesamiento mejorado:
CLAHE (Contrast Limited Adaptive Histogram Equalization)
Filtrado median para reducci√≥n de ruido
Detecci√≥n de bordes Canny optimizada
An√°lisis de contornos y √°reas
Densidad de bordes para detecci√≥n de presencia
Pipeline de Procesamiento de Imagen
Arquitectura de An√°lisis en Tiempo Real

COMPUTER VISION AVANZADA:
   - Segmentaci√≥n sem√°ntica con U-Net para identificar regiones de inter√©s
   - Optical flow para tracking de movimiento de cartas y fichas
   - Keypoint detection para alineaci√≥n y perspectiva correction
   - Data augmentation en tiempo real con GANs para mejorar robustez



Para lograr una lectura eficiente:

Desactivar el uso de overlays para forzar tu contenido a pasar por software y as√≠ capturarlo.

Cambiar el modo del monitor o forzar tearing para romper la ruta segura.

Usa OCR, ML o screen scraping indirecto (ej. captura de subventanas).





6. Requisitos de Anti-Detecci√≥n:


Implementar t√©cnicas avanzadas de evasi√≥n incluyendo randomizaci√≥n de timing, ocultaci√≥n completa de operaciones de captura. El sistema debe ser completamente invisible para los sistemas anti-cheat de las salas de p√≥ker.


6.1. OBJETIVO ESPEC√çFICO:
Desarrollar un sistema de computer vision altamente especializado que supere las protecciones de renderizado del cliente de poker mediante t√©cnicas avanzadas de procesamiento de imagen y machine learning, enfocado en la m√°xima precisi√≥n de lectura.

6.2. CARACTER√çSTICAS CR√çTICAS PARA SUPERAR PROTECCIONES:
SISTEMA DE CAPTURA DE ALTA FRECUENCIA
PREPROCESAMIENTO AVANZADO PARA ANTI-ALIASING 
DETECCI√ìN DE ELEMENTOS CON COMPUTER VISION AVANZADA

6.3. ARQUITECTURA DE VISI√ìN MEJORADA:
PIPELINE DE PROCESAMIENTO ROBUSTO
SISTEMA DE FUSI√ìN MULTI-MODAL
DETECTOR DE ANOMAL√çAS Y AUTO-CORRECCI√ìN



7. Componentes del programa:


El sistema debe dividirse en m√≥dulos bien organizados algunos tambien especificados mediante plugins:


7.1. M√≥dulo de detecci√≥n de ventana

En lo posible debe localizar en tiempo real la ventana de la mesa de juego y no la pantalla main o lobby del cliente de p√≥ker.

Debe solicitar al usuario que indique cual es la ventana de la mesa de poker para analizar.

Nunca mostrar analisis simulados.

Debe recuperar sus coordenadas y tama√±o.

Si la ventana se mueve, el programa debe adaptarse autom√°ticamente.


7.2. M√≥dulo de Gesti√≥n de Memoria/GPU (Memory Leaks):

import gc
# Cada 1000 frames (aprox cada minuto)
if contador_frames % 1000 == 0:
    gc.collect() # Forzar al basurero de Python a limpiar RAM suelta


7.3. M√≥dulo de sistema de ‚Äúhealth check‚Äù de visi√≥n:

Tu funci√≥n verificar_vision() como auto-diagn√≥stico.
Integrarla como plugin de diagn√≥stico:
Detecci√≥n de pantalla negra (bajo brillo + baja desviaci√≥n).
Reporte en la UI: ‚ÄúEstado captura: OK / Pantalla protegida / Ventana minimizada‚Äù.
Detectar fehacientemente protecciones de contenido protegido y reportarlo correctamente al usuario en el GUI.


7.4. Modulos adicionales a discrecion.



8. C√≥digo principal: Archivo: "htp.py" (los ejemplos de codigo siempre son como referencia y deben ser optimizados y debugeados:

No debe tener l√≥gica de p√≥ker. Su √∫nico trabajo es:

Cargar Configuraci√≥n (config.json).

Cargar Plugins din√°micamente desde la carpeta /plugins.

Iniciar el Bucle Infinito (Orchestrator Loop).

Manejar excepciones globales (para que el bot no se cierre si falla el OCR un segundo).

Debe implementar un Shared State Dictionary (Estado Compartido) thread-safe que pase por todos los plugins en cada ciclo.

Actualmente se asume un solo hilo principal; si se introducen hilos adicionales, debe a√±adirse sincronizaci√≥n.



Ejemplo de estructura inicial:



import asyncio
import json
import os
import sys
import time
import logging
import importlib.util
import gc
import traceback
import inspect
import psutil
from typing import Dict, Any, List

# ==========================================
# 1. SISTEMA DE LOGGING CENTRALIZADO
# ==========================================
if not os.path.exists("logs"):
    os.makedirs("logs")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(module)s: %(message)s",
    handlers=[
        logging.FileHandler("logs/system.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("HTP_Core")

# ==========================================
# 2. ESTADO COMPARTIDO (Thread-Safe Bus)
# ==========================================
class SharedState(dict):
    """
    El Cerebro Central de Datos.
    Act√∫a como un bus de comunicaci√≥n. Los plugins no se llaman entre s√≠,
    leen y escriben en este diccionario compartido.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.update({
            # --- Control del Sistema ---
            "running": True,           # Interruptor maestro
            "fps_current": 0.0,        # Monitor de rendimiento real
            "target_fps": 5,           # Objetivo din√°mico (5 idle / 30 active)
            "errors": [],              # Cola de errores para la GUI

            # --- Capa 1: Entrada ---
            "window_rect": None,       # (x, y, w, h) de la ventana de p√≥ker
            "window_title": "",        # T√≠tulo detectado
            "frame": None,             # Imagen actual procesada (numpy array)
            "frame_timestamp": 0.0,    # Para sincronizaci√≥n

            # --- Capa 2: Visi√≥n (YOLO) ---
            "detections": [],          # Lista de objetos detectados [{label, conf, box}]
            "hero_active": False,      # TRIGGER: ¬øEs mi turno?
            "table_size": 6,           # 6-max o 9-max detectado
            "dealer_pos": None,        # Ubicaci√≥n del dealer (x, y)

            # --- Capa 3: OCR & Datos ---
            "ocr_data": {              # Datos le√≠dos del pa√±o
                "pot": 0.0,
                "stacks": {},          # {seat_index: amount}
                "bets": {}             # {seat_index: amount}
            },

            # --- Capa 4: Estrategia (Cerebro) ---
            "game_state": {            # Estado l√≥gico reconstruido
                "my_cards": [],        # Objetos Card
                "board": [],           # Objetos Card
                "street": "PREFLOP",
                "dealer_seat": -1,
                "blinds": {"sb": 0.0, "bb": 0.0}
            },
            "decision": {              # Output final para el usuario
                "action": "ESPERANDO...",
                "equity": "--%",
                "ev": 0.0,
                "tags": [],            # ["DURISIMO", "3-BET POT"]
                "color": "gray",       # Para la UI
                "pot_odds": ""
            },
            
            # Diagn√≥stico
            "vision_ok": False,
            "system_checked": False
        })

# ==========================================
# 3. GESTOR DE PLUGINS (Modularidad)
# ==========================================
class PluginLoader:
    def __init__(self, plugin_dir: str = "plugins"):
        self.plugin_dir = plugin_dir
        self.plugins: Dict[str, Any] = {}

        # ORDEN CR√çTICO DE EJECUCI√ìN (Pipeline)
        # Definido seg√∫n Prompt 2.9 para flujo l√≥gico de datos:
        # Diagn√≥stico -> Ventana -> Captura -> Visi√≥n -> OCR -> Estrategia -> UI
        self.load_order: List[str] = [
    		"self_check_plugin",       # 0. Diagn√≥stico inicial
    		"window_detector_plugin",  # 1. Localizar ventana (pygetwindow/OCR)
    		"input_handler",           # 2. Gestionar fuente de captura (DXcam)
   		"vision_core",             # 3. Detecci√≥n YOLO (Cartas, Mesa)
    		"advanced_ocr_plugin",     # 4. Lectura de Dinero (EasyOCR)
    		"main_player_decisions",   # 5. L√≥gica de P√≥ker (Eval7 + Tablas)
    		"HTPGUI",                  # 6. Servidor Web (Interfaz)
    		"blinds_detector",         # 7. Ciegas desde t√≠tulo
    		"errores",                 # 8. Debug/diagn√≥stico
]

    def load_plugins(self) -> None:
        """Carga din√°mica de m√≥dulos sin hardcodear imports."""
        if not os.path.exists(self.plugin_dir):
            os.makedirs(self.plugin_dir)
            init_path = os.path.join(self.plugin_dir, "__init__.py")
            if not os.path.exists(init_path):
                open(init_path, "w").close()

        logger.info("üîå Iniciando carga de plugins...")

        for module_name in self.load_order:
            try:
                self._load_single(module_name)
            except ImportError as e:
                logger.error(f"‚ùå Dependencia faltante en '{module_name}': {e}")
            except Exception as e:
                logger.error(f"‚ùå Error cargando '{module_name}': {e}")
                traceback.print_exc()

    def _load_single(self, module_name: str) -> None:
        path = os.path.join(self.plugin_dir, f"{module_name}.py")
        if not os.path.exists(path):
            # Warning suave, porque algunos plugins pueden no estar listos a√∫n
            logger.warning(f"‚ö†Ô∏è Plugin no encontrado: {path} (Saltando)")
            return

        # Carga din√°mica
        spec = importlib.util.spec_from_file_location(module_name, path)
        if spec is None or spec.loader is None:
             logger.error(f"‚ùå No se pudo crear spec para {module_name}")
             return
             
        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module
        spec.loader.exec_module(module)

        # Instanciaci√≥n autom√°tica de la clase principal
        # Busca una clase que termine en 'Plugin' (ej: VisionCorePlugin)
        found = False
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if (
                isinstance(attr, type)
                and attr_name.endswith("Plugin")
                and attr_name != "BasePlugin"
            ):
                try:
                    self.plugins[module_name] = attr()
                    logger.info(f"‚úÖ Plugin activo: {module_name} -> {attr_name}")
                    found = True
                    break
                except Exception as e:
                     logger.error(f"‚ùå Error instanciando {attr_name}: {e}")

        if not found:
            logger.warning(f"‚ö†Ô∏è No se encontr√≥ clase '...Plugin' en {module_name}")

# ==========================================
# 4. ORQUESTADOR PRINCIPAL (Core Loop)
# ==========================================
class HTPOrchestrator:
    def __init__(self):
        self.state = SharedState()
        self.loader = PluginLoader()
        self.config = self._load_config()

        # Crear estructura de carpetas necesaria
        for d in ["logs", "config", "plugins", "errores"]:
            os.makedirs(d, exist_ok=True)

    def _load_config(self) -> Dict[str, Any]:
        """Carga configuraci√≥n resistente a fallos."""
        default_conf: Dict[str, Any] = {
            "fps_idle": 5,
            "fps_active": 30,
            "debug_mode": False,
            "save_errors": True
        }
        try:
            with open("config/config.json", "r") as f:
                data = json.load(f)
                default_conf.update(data)
                return default_conf
        except Exception:
            logger.warning("config.json no encontrado. Usando defaults.")
            return default_conf

    async def start(self) -> None:
        logger.info("üöÄ HTP Engine v3.0 Iniciando...")

        # 1. Cargar Plugins
        self.loader.load_plugins()

        # 2. Setup Inicial (Configuraci√≥n de cada plugin)
        for name, plugin in self.loader.plugins.items():
            setup_fn = getattr(plugin, "setup", None)
            if setup_fn:
                logger.info(f"‚öôÔ∏è Configurando {name}...")
                try:
                    if inspect.iscoroutinefunction(setup_fn):
                        await setup_fn(self.state, self.config)
                    else:
                        setup_fn(self.state, self.config)
                except Exception as e:
                    logger.error(f"‚ùå Error en setup de {name}: {e}")

        # 3. Arrancar Bucle
        await self.main_loop()

    async def main_loop(self) -> None:
        logger.info("üü¢ Bucle Principal Iniciado")
        frame_count = 0

        while self.state["running"]:
            loop_start = time.time()

            # --- A. DETERMINAR MODO DE ENERG√çA ---
            # Si 'hero_active' es True (detectado por vision_core), subimos a 30 FPS.
            # Si no, bajamos a 5 FPS para ahorrar CPU y ser "stealth".
            is_active = self.state.get("hero_active", False)
            target_fps = self.config["fps_active"] if is_active else self.config["fps_idle"]
            self.state["target_fps"] = target_fps

            # --- B. PIPELINE DE EJECUCI√ìN ---
            # Ejecutamos los plugins en el orden estricto de load_order
            for name in self.loader.load_order:
                plugin = self.loader.plugins.get(name)
                if not plugin:
                    continue

                # Optimizaci√≥n: Algunos plugins pueden saltarse si estamos en Idle
                # El OCR y la L√≥gica de Juego solo corren si es mi turno
                if (not is_active) and name in ["advanced_ocr_plugin", "main_player_decisions"]:
                    continue

                try:
                    # Inyecci√≥n de Dependencia: Pasamos el Estado Compartido
                    if hasattr(plugin, "process"):
                        res = plugin.process(self.state)
                        if inspect.iscoroutine(res):
                            await res
                            
                except Exception as e:
                    # Resiliencia: Si un plugin falla, el bot NO muere.
                    err_msg = f"Error en {name}: {str(e)}"
                    # Evitamos inundar el log con el mismo error 30 veces por segundo
                    if not self.state["errors"] or self.state["errors"][-1] != err_msg:
                        logger.error(err_msg)
                        self.state["errors"].append(err_msg)
                        # Limitar tama√±o de la cola de errores
                        if len(self.state["errors"]) > 100:
                            self.state["errors"].pop(0)
                    
                    if self.config.get("debug_mode"):
                        traceback.print_exc()

            # --- C. GESTI√ìN DE MEMORIA (GC) ---
            frame_count += 1
            if frame_count % 500 == 0:
                gc.collect()  # Limpieza forzada cada ~X ciclos
                # Health Check b√°sico de RAM
                process = psutil.Process(os.getpid())
                mem = process.memory_info().rss / 1024 / 1024 # MB
                if mem > 2000: # Si usa m√°s de 2GB
                     logger.warning(f"‚ö†Ô∏è Consumo de RAM alto: {mem:.0f}MB. Forzando limpieza...")
                     gc.collect()

            # --- D. CONTROL DE LATENCIA (Sleep) ---
            elapsed = time.time() - loop_start
            self.state["fps_current"] = round(1.0 / elapsed, 1) if elapsed > 0 else 0.0

            sleep_time = (1.0 / target_fps) - elapsed
            if sleep_time > 0:
                await asyncio.sleep(sleep_time)
            else:
                # Ceder control m√≠nimo para IO / otros tasks
                await asyncio.sleep(0.001)

# --- PUNTO DE ENTRADA ---
if __name__ == "__main__":
    bot = HTPOrchestrator()
    try:
        # Fix para Windows Asyncio (Importante para Uvicorn)
        if sys.platform == "win32":
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

        asyncio.run(bot.start())

    except KeyboardInterrupt:
        logger.info("üõë Deteniendo HTP...")
    except Exception as e:
        logger.critical(f"üî• ERROR FATAL: {e}")
        traceback.print_exc()
        input("Presiona Enter para salir...")










9. Archivo de configuraci√≥n "config.json":

Con los par√°metros antes mencionados sin olvidar las coordenadas de todos los elementos importantes de las mesas.






10. Script de compilaci√≥n PyInstaller

Archivo: htp.spec, que incluya:

config.json

Pathex correctos

Modo ventana o consola seleccionable

Compatibilidad con compilaci√≥n de un solo archivo (opcional)



11. Script "instalar.bat". Debe crear la estructura.

HTP/
‚îú‚îÄ‚îÄ htp.py                 # Core (Carga plugins y corre el loop)
‚îú‚îÄ‚îÄ ... (archivos ra√≠z)
‚îî‚îÄ‚îÄ plugins/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ input_handler.py           # DXcam / Detecci√≥n de Ventana
    ‚îú‚îÄ‚îÄ vision_core.py             # YOLO + L√≥gica de Mesa (Dealer/Cartas)
    ‚îú‚îÄ‚îÄ advanced_ocr_plugin.py     # EasyOCR + Limpieza de texto
    ‚îú‚îÄ‚îÄ HTPGUI.py                  # FastAPI + WebSocket + HTML/CSS
    ‚îú‚îÄ‚îÄ window_detector_plugin.py  # Mira la ventana.
    ‚îú‚îÄ‚îÄ blinds_detector.py
    ‚îú‚îÄ‚îÄ errores.py
    ‚îú‚îÄ‚îÄ main_player_decisions.py   # (que use PreflopBrain + PostflopBrain + PlayerProfile)
    ‚îî‚îÄ‚îÄ self_check_plugin.py       # (autodiagn√≥stico con verificar_vision, check de dependencias, etc.)



12. Archivo de instalacion HTP.spec


13. Optimizaci√≥n

El programa debe estar optimizado para:

Baja latencia (<150 ms por frame)

Buen funcionamiento en resoluciones 2K

Procesamiento OCR eficiente

Estabilidad ante perdida de ventana


14. Resultado final esperado

Generar un proyecto listo para:

Compilar con PyInstaller

Configurado automaticamente mediante JSON

Que utilice como metodo principal de reconocimiento las librerias YOLOv11 + OpenCV.

Escalar autom√°ticamente a la ventana visible

Reescribir la clase WindowDetector de Python para que detecte la ventana de un cliente de poker aunque el t√≠tulo cambie din√°micamente priorizando el metodo Regex, o haciendo OCR de ventana estos deben:

Registrar todas las ventanas encontradas para depuraci√≥n.

Mantener un fallback por OCR que busque palabras clave en pantalla (case-insensitive) y devuelva las coordenadas del rect√°ngulo de la ventana.

Ser thread-safe y actualizar window_rect correctamente.

Incluir boton para inicio del analisis y pausa. 

M√≥dulo de autodiagn√≥stico interactivo, donde el software: verifica dependencias y configuraciones, detecta fallas, le pregunta al usuario si funciona correctamente, sugiere o aplica soluciones autom√°ticas.

Panel GUI moderno y reactivo con gr√°ficos en tiempo real, historial de manos, alertas y exportaci√≥n de datos updated live.

El plugin de api de GEMINI IA mas adelante sera actualizado para el uso de APIs.

El programa debe estar ubicado en "C:\HTP".

Ejemplos de estructura inicial (se puede ampliar a conveniencia):

Ejemplo inicial:



Ejemplo expandido posteriormente con plugins:

HTP/
‚îú‚îÄ‚îÄ htp.py                # Archivo principal
‚îú‚îÄ‚îÄ config.json           # Configuraci√≥n principal
‚îú‚îÄ‚îÄ htp.spec              # Configuraci√≥n PyInstaller
‚îú‚îÄ‚îÄ build.bat             # Script de compilaci√≥n
‚îú‚îÄ‚îÄ install_dependencies.bat
‚îú‚îÄ‚îÄ icoRGB.ico            # Icono de la aplicaci√≥n
‚îú‚îÄ‚îÄ interface.css         # Theme de la interfaz web.
‚îú‚îÄ‚îÄ README.txt            # Documentaci√≥n
‚îÇ
‚îú‚îÄ‚îÄ plugins/              # Directorio principal de plugins
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py       # Inicializador de plugins
‚îÇ   ‚îú‚îÄ‚îÄ core/             # Plugins del sistema core
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ window_detector_plugin.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ advanced_ocr_plugin.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main_player_decisions.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card_detector_plugin.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blinds_detector.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errores.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ poker_ai_plugin.py
‚îÇ   ‚îú‚îÄ‚îÄ capture/          # Plugins de captura
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screen_capture.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ window_capture.py
‚îÇ   ‚îú‚îÄ‚îÄ analysis/         # Plugins de an√°lisis
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hand_analyzer.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ odds_calculator.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ strategy_engine.py
‚îÇ   ‚îî‚îÄ‚îÄ interface/        # Plugins de interfaz
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ modern_gui.py
‚îÇ       ‚îî‚îÄ‚îÄ overlay_manager.py
‚îÇ
‚îú‚îÄ‚îÄ logs/                 # Logs del sistema
‚îÇ   ‚îú‚îÄ‚îÄ system.log
‚îÇ   ‚îú‚îÄ‚îÄ detection.log
‚îÇ   ‚îî‚îÄ‚îÄ performance.log
‚îÇ
‚îî‚îÄ‚îÄ config/              # Configuraciones adicionales
    ‚îú‚îÄ‚îÄ preflop_charts.json
    ‚îú‚îÄ‚îÄ player_profiles.json
    ‚îî‚îÄ‚îÄ table_templates.json

HTP\yoloDS\runs\detect\HTP_v11_final\weights\best_openvino_model\


15. Enviroment (y software ya instalado para evitar conflictos y NO PEDIR QUE SE REINSTALE NO PEDIR CONFIRMACION):

Windows 10

Archivos y carpetas ya preparados:

HTP/
‚îú‚îÄ‚îÄ icoRGB.ico            # Icono de la aplicaci√≥n
‚îú‚îÄ‚îÄ interface.css         # Theme de la interfaz web.
‚îî‚îÄ‚îÄ config/              # Configuraciones adicionales
    ‚îî‚îÄ‚îÄ preflop_charts.json

HTP\yoloDS\runs\detect\HTP_v11_final\weights\best_openvino_model\best.xml





# Si no est√° en las listas de arriba, asumiremos que es una carta.











16. Ejemplo a mejorar de "plugins/blinds_detector.py":



La mayor√≠a de los clientes de p√≥ker ponen el nivel de ciegas en la barra de t√≠tulo de la ventana (ej: "NLH $0.50/$1.00 - Table 1"). Pero no confundir con la ventana del lobby que puede utilizar el nombre del cliente de poker).

import pygetwindow as gw
import re

class BlindsDetector:
    def __init__(self):
        # Regex para encontrar patrones de dinero: "$0.50 / $1.00" o "100/200"
        # Soporta: $, ‚Ç¨, ¬•, ¬£, y n√∫meros con punto o coma decimal
        self.patron_ciegas = r"(?:[\$‚Ç¨¬•¬£C]|BB)?\s*(\d+(?:[.,]\d+)?)\s*/\s*(?:[\$‚Ç¨¬•¬£C]|BB)?\s*(\d+(?:[.,]\d+)?)"
        
        # Palabras clave para IGNORAR (Falsos positivos como el Lobby)
        self.lista_negra = ["Lobby", "Tournament", "Torneo", "Log In", "Manager"]

    def buscar_ventana_mesa(self):
        """
        Escanea todas las ventanas visibles.
        Retorna: (t√≠tulo_ventana, small_blind, big_blind)
        """
        todas_ventanas = gw.getAllTitles()
        
        for titulo in todas_ventanas:
            # 1. Filtro r√°pido: Ignorar ventanas vac√≠as o del sistema
            if not titulo or titulo == "": continue
            
            # 2. Filtro de Lista Negra (Evitar el Lobby expl√≠citamente si dice "Lobby")
            if any(palabra in titulo for palabra in self.lista_negra):
                continue

            # 3. B√∫squeda del Patr√≥n de Ciegas (El coraz√≥n de la l√≥gica)
            # Buscamos algo que parezca "X / Y" num√©ricamente
            match = re.search(self.patron_ciegas, titulo)
            
            if match:
                try:
                    # Extraer los grupos del regex
                    sb_str = match.group(1).replace(',', '.') # Normalizar 0,50 a 0.50
                    bb_str = match.group(2).replace(',', '.')
                    
                    sb = float(sb_str)
                    bb = float(bb_str)
                    
                    # Filtro de cordura: La ciega grande debe ser mayor o igual a la chica
                    if bb >= sb:
                        return titulo, sb, bb
                        
                except ValueError:
                    continue # Si falla la conversi√≥n, no era una mesa v√°lida

        return None, 0.0, 0.0

# --- BLOQUE DE PRUEBA (Para que lo corras ahora y verifiques) ---
if __name__ == "__main__":
    detector = BlindsDetector()
    print("üîç Escaneando ventanas en busca de mesas de p√≥ker...")
    
    titulo, sb, bb = detector.buscar_ventana_mesa()
    
    if titulo:
        print(f"\n‚úÖ MESA ENCONTRADA:")
        print(f"   T√≠tulo: '{titulo}'")
        print(f"   Small Blind: {sb}")
        print(f"   Big Blind:   {bb}")
        print(f"   Stack de 100BB ser√≠a: {bb * 100}")
    else:
        print("\n‚ùå No se detectaron mesas activas.")
        print("   Aseg√∫rate de que la ventana de la mesa (no el lobby) est√© abierta.")



Si esto no tiene exito debemos como manera secundaria definir de manera manual el importe desde GUI.



















17. Descripcion y funciones del plugin "vision_core.py":



Se utiliza s√≥lo para detecci√≥n YOLO + clasificaci√≥n de objetos (cartas, dealer, regiones OCR, etc). Escribe resultados en SharedState["detections"] y quiz√° SharedState["game_state"]["my_cards"/"board"].


Para cumplir su funcion "vision_core.py" se hara cargo de las siguientes definiciones ZONAS_EXCLUSIVAS_9MAX, detectar_formato_mesa, detectar_mesa_y_dealer, ordenar_asientos_por_angulo

Ejemplos a mejorar unificar e implementar de vision_core.py:


Codigos y datos relativos a los datos obtenidos del OCR de la mesa:

import math

# --- CONFIGURACI√ìN DE ZONAS 9-MAX (Normalizadas 0.0 a 1.0) ---
# Estas zonas representan las esquinas inferiores "apretadas" t√≠picas de 9-max.
# Si detectamos un stack o asiento vac√≠o aqu√≠, es mesa de 9.
ZONAS_EXCLUSIVAS_9MAX = [
    # x_min, y_min, x_max, y_max
    (0.12, 0.65, 0.22, 0.85), # Asiento extra izquierda
    (0.78, 0.65, 0.88, 0.85)  # Asiento extra derecha
]

def calcular_distancia(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def detectar_formato_mesa(puntos_interes, ancho_img, alto_img):
    """
    Analiza si alg√∫n objeto cae en zonas exclusivas de 9-max.
    puntos_interes: lista de tuplas (x_centro, y_centro)
    """
    for x, y in puntos_interes:
        # Normalizar a 0.0-1.0
        x_norm = x / ancho_img
        y_norm = y / alto_img
        
        for (x1, y1, x2, y2) in ZONAS_EXCLUSIVAS_9MAX:
            if x1 < x_norm < x2 and y1 < y_norm < y2:
                return 9 # Es mesa de 9
    return 6 # Por defecto asumimos 6 (o 3, que usa el mismo layout)





















18. Ejemplo a mejorar del modulo de toma de desiciones "main_player_decisions.py":

‚ÄúEl m√≥dulo main_player_decisions.py implementar√°:

Una clase PreflopBrain con la siguiente interfaz can√≥nica:
__init__(ruta_json: str) ‚Äì ruta se lee desde config.json.
normalizar_mano(cartas: list[eval7.Card]) -> str
obtener_consejo(mis_cartas, posicion_hero, accion_previa) donde accion_previa es 'NADIE' o 'RAISE'.
Una clase PostflopBrain con:
calcular_equity(mis_cartas, board, perfil_rival: str) -> float
obtener_consejo(equity, bote_total, costo_call) -> str
Una clase PlayerProfile tal como se muestra en el ejemplo, sin cambios de firma.‚Äù

Las m√∫ltiples versiones de ejemplo son ‚Äúvariantes‚Äù y que se tomar√°n como referencia para implementar una s√≥la versi√≥n unificada.


El M√≥dulo de Toma de Decisiones es el "main_player_decisions.py" que conecta los ojos (YOLO) con la acci√≥n. No es un bloque monol√≠tico, sino una tuber√≠a de procesamiento (pipeline) de 4 etapas.

El flujo de datos debe ser unidireccional:

Datos Crudos (YOLO) + Ciegas + Normalizaci√≥n + Matem√°ticas + Ajuste Psicol√≥gico = Decisi√≥n Final.

A) El Normalizador de Estado (State Normalizer)

YOLO te da coordenadas y OCR te da n√∫meros "sucios". Este componente limpia y traduce todo al "idioma del p√≥ker".

Input: pot=35.50, stack=100, blind_value=0.50.

Funci√≥n: Convierte dinero a Ciegas Grandes (BB) y determina la posici√≥n relativa.

Output:

pot_bb: 71 BB

street: "PREFLOP", "FLOP", "TURN" o "RIVER".

B) El Motor Pre-Flop (Tablas de Rangos)

El p√≥ker se juega muy diferente antes y despu√©s de las cartas comunitarias.

L√≥gica: No se calcula equity compleja. Se usan Tablas de Rangos (Lookup Tables).

Funcionamiento:

Si street == "PREFLOP":

Busca en un archivo Excel/JSON: "Tengo AKs en posici√≥n UTG. ¬øQu√© dice la tabla?"

Respuesta: "Raise a 3BB".

C) El Motor Post-Flop (Calculadora Matem√°tica):

Aqu√≠ entra eval7 o PokerKit. Se activa cuando hay cartas en la mesa.

C√°lculo 1 (Equity): ¬øQu√© probabilidad tengo de ganar? (Ej. 60%).
C√°lculo 2 (Pot Odds): ¬øCu√°nto me cuesta pagar? (Ej. Tengo que poner 10 en un bote de 20: necesito 33% de equity).
C√°lculo 3 (EV - Valor Esperado): EV = (\%Win \times \$Ganancia) - (\%Lose \times \$Costo).

D) La Capa Explotativa:

def logica_postflop(self, state, perfil_rival):
        """
        state: Datos de la mesa (cartas, dinero)
        perfil_rival: "DURISIMO", "REGULAR", "FLOJO" (Viene del Tracker)
        """
        
        # Calcular Pot Odds (Matem√°tica Pura)
        # Cu√°nto tengo que poner / (Bote total + Lo que pongo)
        costo_call = state['amount_to_call']
        bote_total = state['pot_total'] + costo_call
        
        if bote_total == 0: pot_odds = 0
        else: pot_odds = costo_call / bote_total
        
        # Calcular Equity Base (Matem√°tica Pura - eval7/PokerKit)
        # Probabilidad real de que tus cartas ganen al showdown
        equity_real = calcular_equity(state['my_cards'], state['board_cards'])
        
        # Generar la Sugerencia Matem√°tica (GTO Base)
        if equity_real > pot_odds:
            # Si tengo m√°s probabilidad de ganar que el precio del bote
            if equity_real > 0.70:
                sugerencia = "RAISE / ALL-IN"
            else:
                sugerencia = "CALL"
        else:
            sugerencia = "FOLD"
            
        # Empaquetar para el Frontend.
        # Enviamos los datos separados: La Verdad Matem√°tica + La Opini√≥n Psicol√≥gica
        return {
            "action_math": sugerencia,          # "CALL"
            "equity_math": f"{equity_real:.1%}", # "42.5%" (Puro)
            "pot_odds": f"{pot_odds:.1%}",       # "33.0%" (Precio)
            "opponent_tag": perfil_rival         # "DURISIMO" (Contexto)
        }


Integracion del factor de las Ciegas:

Se debe convertir todo el dinero a BBs antes de tomar decisiones.

Estrategias de mejora en la toma de desiciones:

Tecnicas "Anti-Bluff": El programa debe tener memoria en la partida es decir debe recordar a los oponentes y su comportamiento, por ejemplo si determinado oponente bluffea constantemente esto debe ser tenido en cuenta para la desicion de la proxima jugada para esta funcion debe aplicarse el concepto de "Captura √önica" (The One Snapshot) es por eso que debe detectarse el evento "nueva mano" o usar la libreria imagehash (La alternativa ligera) para esto debemos usar un Diccionario en Python para vincular Nombre -> Estad√≠sticas. Si el OCR detecta un nombre nuevo en la misma silla $\rightarrow$ Borra las estad√≠sticas viejas de esa silla y empieza a contar de cero para el nuevo tipo. Se realiza de la siguiente forma en 3 pasos:

A) Individualizar oponente:
import easyocr
reader = easyocr.Reader(['en']) # Cargar modelo en memoria (hazlo una vez al inicio)

# Diccionario de la sesi√≥n actual
# Key: N√∫mero de Silla (0-8), Value: Nombre del Jugador
ocupantes_actuales = {} 

def verificar_jugadores(frame, coordenadas_asientos):
    for silla_id, (x, y, w, h) in coordenadas_asientos.items():
        
        # 1. Recortar el √°rea del nombre (ROI)
        # Ajusta estos valores seg√∫n tu mesa
        roi_nombre = frame[y-30:y, x:x+w] 
        
        # 2. Leer el nombre
        resultado = reader.readtext(roi_nombre, detail=0)
        nombre_detectado = resultado[0] if resultado else "Desconocido"
        
        # 3. Verificar cambios
        nombre_anterior = ocupantes_actuales.get(silla_id)
        
        if nombre_detectado != nombre_anterior:
            print(f"Cambio en silla {silla_id}: Sale {nombre_anterior}, Entra {nombre_detectado}")
            
            # REINICIAR ESTAD√çSTICAS para esta silla
            base_de_datos_stats[silla_id] = {"manos": 0, "vpip": 0}
            
            # Actualizar ocupante
            ocupantes_actuales[silla_id] = nombre_detectado

B) Sistema de Perfilado en Tiempo Real (Session-Based Profiling) mediante L√≥gica Heur√≠stica Din√°mica el script debe funcionar con un sistema de Suposiciones Base (Baseline) que se ajustan r√°pidamente.

Mano 0: El bot asume que el rival es un "Jugador Promedio" (ni muy loco, ni muy roca). Usa tablas est√°ndar.

Mano 10: El bot ya vio algunas acciones. Empieza a desviarse del promedio.

Mano 30: El bot ya tiene un perfil "de sesi√≥n" s√≥lido para ese jugador.

class PlayerProfile:
    def __init__(self):
        self.manos_vistas = 0
        self.veces_entro = 0  # VPIP
        self.veces_subio = 0  # PFR
        self.etiqueta = "UNKNOWN" # Desconocido

    def actualizar(self, accion):
        self.manos_vistas += 1
        if accion == "call" or accion == "raise":
            self.veces_entro += 1
        if accion == "raise":
            self.veces_subio += 1
        
        # EL CEREBRO: Clasificaci√≥n en tiempo real
        self.clasificar_jugador()

    def clasificar_jugador(self):
        # 1. Si tengo pocos datos, no opino
        if self.manos_vistas < 10:
            self.etiqueta = "UNKNOWN"
            return

        # 2. C√°lculo simple
        vpip = (self.veces_entro / self.manos_vistas) * 100
        
        # 3. Reglas Heur√≠sticas (Aqu√≠ ajustas tu estrategia)
        if vpip > 60:
            self.etiqueta = "FLOJO" # Juega demasiadas manos
        elif vpip < 15:
            self.etiqueta = "DURISIMO" # Solo juega manos premium
        else:
            self.etiqueta = "REGULAR"

C) Imprimir el resultado del Dato Psicol√≥gico del rival: EJ "Dato Psicol√≥gico (Rival: DURISIMO)" Adem√°s de calcular el equity.


D) Manejar el reinicio (Identificacion):

Para que esto funcione en una sesi√≥n donde la gente entra y sale:

En cada nueva mano, verificar si el nombre/avatar en la "Silla 3" (por ejemplo) es el mismo que en la mano anterior.

Si es distinto: tracker.reset("Silla_3"). Se borra todo y empieza como "UNKNOWN".

Si es igual: tracker.actualizar(...). Sigue sumando datos.


Ejemplos codificados:


# --- L√ìGICA ESPACIAL (POST-PROCESAMIENTO) ---
    
    # Refinar por Conteo (¬øCu√°ntos lugares activos veo?)
    # puntos incluye: stacks detectados + asientos vac√≠os detectados
    cantidad_lugares = len(puntos)
    
    if es_geometria_grande:
        # Es una mesa ovalada. Puede ser de 8 o 9.
        # Si detectamos 9 lugares, es 9. Si detectamos 8 o menos, asumimos 8 
        # (o 9 con gente oculta, pero para el label usaremos 8).
        if cantidad_lugares >= 9:
            return 9
        return 8
    else:
        # Es una mesa hexagonal/cuadrada. Puede ser de 2, 4 o 6.
        if cantidad_lugares <= 4 and cantidad_lugares > 0:
            return 4
        return 6


# --- L√ìGICA DE DECISI√ìN Y ESTADOS ---

        # Variable clave: ¬øTengo mano para jugar?
        # (Requiere 2 cartas detectadas y que NO sean cartas grises de fold)
        tengo_cartas = len(mis_cartas_obj) >= 2
        
        # --- ESTADO 0: MODO ESPERA (Standby) ---
        if not tengo_cartas:
            # Si no tengo cartas, limpiamos la memoria y esperamos.
            # Esto previene c√°lculos in√∫tiles entre manos.
            memoria["equity"] = "--%"
            memoria["advice"] = "..."
            memoria["tag"] = "---"
            
            estado_global.update({
                "equity": "--%",
                "advice": "ESPERANDO MANO ‚è≥",
                "opponent_type": "Mesa en Pausa",
                "status_color": "gray" # Puedes usar esto en CSS para ponerlo gris
            })
            
            # Peque√±a pausa extra para ahorrar CPU mientras esperamos cartas
            await asyncio.sleep(0.1) 
            
        # --- ESTADO 1: ACCI√ìN (Es mi turno) ---
        elif es_mi_turno and tengo_cartas:
            
            # Detectar formato (4, 6, 8, 9)
            tamanio = detectar_formato_mesa(objetos_mesa, frame.shape[1], frame.shape[0])
            
            # Calcular Matem√°tica
            equity = calcular_equity(mis_cartas_obj, board_obj)
            
            # Guardar en Memoria
            memoria["equity"] = f"{equity*100:.1f}%"
            
            if equity > 0.6: memoria["advice"] = "RAISE üü¢"
            elif equity > 0.4: memoria["advice"] = "CALL üü°"
            else: memoria["advice"] = "FOLD üî¥"
            
            memoria["tag"] = f"{tamanio}-Max"

            # Enviar a Tablet
            estado_global.update({
                "equity": memoria["equity"],
                "advice": memoria["advice"],
                "opponent_type": f"{memoria['tag']} (TU TURNO)",
                "status_color": "green" # Verde para acci√≥n
            })

        # --- ESTADO 2: SEGUIMIENTO (No es mi turno, pero tengo cartas) ---
        elif not es_mi_turno and tengo_cartas:
            
            # Mantenemos la info en pantalla para que pienses
            estado_global.update({
                "equity": memoria["equity"], 
                "advice": f"√öltimo: {memoria['advice']}",
                "opponent_type": "Esperando rivales...",
                "status_color": "yellow" # Amarillo para espera activa
            })
            
        # Enviar al WebSocket
        await websocket.send_json(estado_global)




    # ENCONTRAR AL DEALER (Vinculaci√≥n)
    # Buscamos qu√© stack de jugador est√° m√°s cerca del bot√≥n de dealer
    jugador_dealer_index = -1
    
    if posicion_dealer and posiciones_stacks:
        distancia_minima = float('inf')
        
        for i, pos_stack in enumerate(posiciones_stacks):
            dist = calcular_distancia(posicion_dealer, pos_stack)
            if dist < distancia_minima:
                distancia_minima = dist
                jugador_dealer_index = i # Este √≠ndice corresponde a la lista posiciones_stacks
        
        # Opcional: Dibujar l√≠nea en debug o imprimir
        # print(f"El Dealer est√° en el Stack #{jugador_dealer_index}")

    # --- SALIDA DE DATOS ---
    if len(mis_cartas) >= 2:
        print(f"--- NUEVA LECTURA ---")
        print(f"Modo: {modo_juego} | Jugadores detectados: {cant_jugadores_activos}")
        print(f"Mis cartas: {mis_cartas}")
        print(f"Board: {cartas_mesa}")
        print(f"Dealer detectado: {'S√ç' if posicion_dealer else 'NO'}")
        
        # Aqu√≠ llamas a tu motor de decisi√≥n pasando estos datos...


    # Detectar tama√±o del bote y cantidad de dinero o fichas de los jugadores:


import cv2
import numpy as np
import re
import easyocr

# Instancia global (para no cargarla en cada frame)
reader = easyocr.Reader(['en'], gpu=False) # True si usas NVIDIA

def preprocesar_imagen_dinero(recorte):
    """
    Transforma un recorte sucio de la mesa en una imagen ideal para OCR.
    """
    if recorte.size == 0: return None

    # 1. Upscaling (Agrandar x3)
    # Usamos INTER_CUBIC que es mejor para mantener bordes suaves en texto
    h, w = recorte.shape[:2]
    img = cv2.resize(recorte, (w*3, h*3), interpolation=cv2.INTER_CUBIC)

    # 2. Convertir a Escala de Grises
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # 3. Thresholding (Binarizaci√≥n Inteligente)
    # Otsu encuentra autom√°ticamente el punto de corte √≥ptimo entre texto y fondo
    _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # 4. Inversi√≥n (Texto Negro sobre Blanco)
    # Verificamos si el fondo es negro (com√∫n en poker). Si es as√≠, invertimos.
    # Contamos p√≠xeles blancos. Si hay pocos, es texto blanco sobre negro -> Invertir.
    if cv2.countNonZero(binary) < (binary.size / 2):
        binary = cv2.bitwise_not(binary)

    # 5. Padding (A√±adir borde blanco seguro)
    binary = cv2.copyMakeBorder(binary, 10, 10, 10, 10, cv2.BORDER_CONSTANT, value=255)

    return binary

def limpiar_texto_dinero(texto_crudo):
    """
    Convierte basura de OCR ("$ 1,200.oo") en float limpio (1200.0)
    """
    if not texto_crudo: return 0.0
    
    # Normalizar: min√∫sculas y reemplazar comas por puntos (o quitarlas)
    texto = texto_crudo.lower().replace(' ', '').replace('o', '0').replace('l', '1')
    
    # Manejar sufijos de p√≥ker (k = mil, m = mill√≥n)
    multiplicador = 1.0
    if 'k' in texto: 
        multiplicador = 1000.0
        texto = texto.replace('k', '')
    elif 'm' in texto: 
        multiplicador = 1000000.0
        texto = texto.replace('m', '')
    elif 'bb' in texto: # Si el soft muestra ciegas
        return 0.0 # O manejar l√≥gica de BB

    # Regex: Extraer solo n√∫meros y punto decimal
    # Busca la secuencia num√©rica m√°s larga
    match = re.search(r"(\d+(?:[\.,]\d+)?)", texto)
    
    if match:
        str_num = match.group(1)
        # Si tiene coma y punto (1,200.50), quitar la coma
        if ',' in str_num and '.' in str_num:
            str_num = str_num.replace(',', '')
        # Si solo tiene coma (1,200), asumimos que es separador de miles si son 3 d√≠gitos
        elif ',' in str_num:
            str_num = str_num.replace(',', '.') # Cuidado aqu√≠ con formatos europeos
            
        try:
            return float(str_num) * multiplicador
        except:
            return 0.0
            
    return 0.0

def leer_dinero_robusto(frame, coords):
    """Pipeline completo de lectura"""
    x1, y1, x2, y2 = map(int, coords)
    
    # Validaci√≥n de coordenadas seguras
    h_img, w_img = frame.shape[:2]
    x1, y1 = max(0, x1), max(0, y1)
    x2, y2 = min(w_img, x2), min(h_img, y2)
    
    recorte = frame[y1:y2, x1:x2]
    
    # FASE A: VISI√ìN
    img_procesada = preprocesar_imagen_dinero(recorte)
    if img_procesada is None: return 0.0
    
    # OCR (Solo caracteres permitidos para evitar leer "A" como "4")
    resultado = reader.readtext(img_procesada, allowlist='0123456789.,$kKmMBb', detail=0)
    
    if not resultado:
        return 0.0
    
    # FASE B: L√ìGICA
    texto_detectado = resultado[0] # Tomamos el m√°s probable
    valor_float = limpiar_texto_dinero(texto_detectado)
    
    return valor_float






# Sistema de coordenadas de posiciones detectadas por YOLO:

def ordenar_asientos_por_angulo(centro_mesa, stacks):
    """
    Ordena los stacks detectados en sentido horario empezando desde las 12 (arriba).
    Esto garantiza que el 'Jugador 0' siempre sea el mismo visualmente.
    """
    def calcular_angulo(punto):
        dx = punto[0] - centro_mesa[0]
        dy = punto[1] - centro_mesa[1]
        # Atan2 devuelve el √°ngulo en radianes
        angulo = math.atan2(dy, dx)
        return angulo

    # Ordenamos la lista de tuplas (x,y) bas√°ndonos en su √°ngulo
    return sorted(stacks, key=calcular_angulo)

# --- USO EN TU BUCLE ---

# 1. Definir el centro de la mesa (aprox)
centro_mesa = (frame.shape[1] / 2, frame.shape[0] / 2)

# 2. Una vez que tienes todos los 'posiciones_stacks' detectados por YOLO:
asientos_ordenados = ordenar_asientos_por_angulo(centro_mesa, posiciones_stacks)

# 3. Ahora s√≠:
# asientos_ordenados[0] -> Siempre ser√° el jugador de m√°s a la derecha/abajo (seg√∫n atan2)
# asientos_ordenados[1] -> El siguiente a su izquierda...




# Aplicaremos dos modos de frecuencia:

Modo Vigilancia (Idle): 5 FPS. Solo busca hero_active (botones).

Modo Acci√≥n (Active): 30 FPS. Ejecuta OCR, YOLO completo y Estrategia.


Incluir la l√≥gica de "Dormir/Despertar" (Con Trigger).

# Estado del turno anterior para evitar repetir la misma acci√≥n
era_mi_turno = False

while True:
    frame = camera.get_latest_frame()
    
    # 1. Inferencia R√°pida (Solo buscamos el gatillo)
    # Usamos conf=0.6 para estar seguros de que son los botones
    results = model(frame, stream=True, conf=0.6)
    
    es_mi_turno_ahora = False
    
    # Escaneo preliminar r√°pido
    for r in results:
        # Check r√°pido si la clase 'hero_action' est√° presente
        # (Esto asume que el ID de 'hero_action' es conocido o lo buscas por nombre)
        for box in r.boxes:
            cls_id = int(box.cls[0])
            nombre = model.names[cls_id]
            if nombre == 'hero_active': # O el nombre que le pongas a los botones
                es_mi_turno_ahora = True
                break
    
    # 2. L√ìGICA DEL GATILLO
    if es_mi_turno_ahora:
        if not era_mi_turno:
            print("¬°DESPERTANDO! Es mi turno. Iniciando an√°lisis completo...")
            
            # --- AQU√ç EJECUTAS TODO EL C√ìDIGO PESADO ---
            # 1. Leer Stacks (OCR)
            # 2. Leer Cartas (Parsing)
            # 3. Calcular Probabilidades (Eval7)
            # 4. Enviar a web.
            
            # (Pega aqu√≠ la l√≥gica que escribimos en la respuesta anterior)
            
        era_mi_turno = True # Marcamos para no re-calcular en el siguiente frame
        
    else:
        if era_mi_turno:
            print("Turno finalizado. Entrando en modo reposo.")
            # Opcional: Enviar mensaje a tablet "Esperando..."
            
        era_mi_turno = False
        # Dormir un poco para ahorrar bater√≠a/CPU
        time.sleep(0.1)



















19. Ejemplo a mejorar del archivo / modulo de deteccion de errores "errores.py":





Deteccion del problema mas recurrente:

import dxcam
import numpy as np
import cv2
import time

def verificar_vision():
    # Inicializar c√°mara (DXcam)
    camera = dxcam.create(output_color="BGR")
    camera.start(target_fps=60)
    
    print("üëÅÔ∏è Iniciando prueba de visi√≥n...")
    print("Por favor, pon la mesa de p√≥ker en pantalla visible.")
    time.sleep(2) # Tiempo para que acomodes la ventana

    try:
        while True:
            frame = camera.get_latest_frame()
            if frame is None: continue

            # --- L√ìGICA DE DETECCI√ìN DE PANTALLA NEGRA ---
            
            # 1. Calcular el promedio de brillo de la imagen
            promedio_brillo = np.mean(frame)
            
            # 2. Calcular la desviaci√≥n est√°ndar (¬øHay variedad de colores?)
            desviacion = np.std(frame)

            # --- DIAGN√ìSTICO ---
            
            # Umbral: Si el brillo promedio es menor a 5 (sobre 255), es negro absoluto
            if promedio_brillo < 5 and desviacion < 5:
                estado = " PANTALLA NEGRA (PROTEGIDA/MINIMIZADA)"
                color_texto = (0, 0, 255) # Rojo
            else:
                estado = f" VISI√ìN CORRECTA (Brillo: {promedio_brillo:.1f})"
                color_texto = (0, 255, 0) # Verde

            # Mostrar en ventana de prueba
            cv2.putText(frame, estado, (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, color_texto, 2)
            cv2.imshow("Prueba de Vision (Q para salir)", frame)

            if cv2.waitKey(1) == ord('q'):
                break
                
    except KeyboardInterrupt:
        pass
    finally:
        camera.stop()
        cv2.destroyAllWindows()

if __name__ == "__main__":
    verificar_vision()












20. M√≥dulo de interfaz: Arquitectura "Invisible" o Air-Gapped (con brecha de aire) "HTPGUI.py" FastAPI + WebSocket:

La interfaz debe ser implementada en un Servidor Web Local (FastAPI): Esta es la arquitectura "Invisible" o Air-Gapped (con brecha de aire). Es la m√°s segura porque la interfaz gr√°fica no existe en tu PC de juego, sino en un dispositivo externo. El cliente de p√≥ker no puede ver lo que hay en la pantalla de tu m√≥vil.

Necesitamos un servidor as√≠ncrono que pueda manejar la captura de pantalla pesada y la comunicaci√≥n web simult√°neamente. Usaremos FastAPI y Uvicorn.

Crea un archivo simple llamado interface.html. No necesitas internet para que funcione, solo tu red local.

la versi√≥n final de HTPGUI.py:
No inicializa dxcam, ni YOLO, ni EasyOCR.
No tiene su propio game_loop.
Se limita a:
Montar FastAPI + WebSocket.
Leer de SharedState["decision"], SharedState["game_state"], SharedState["vision_ok"], etc.
Exponer un endpoint para:
Enviar SharedState a la interfaz web.
Recibir comandos como ‚Äúguardar_error‚Äù u otros.


Con ventana compacta que muestre en tiempo real:

La informacion detectada en el juego

La impresion de forma dinamica en todo momento el mejor curso de accion posible para ganar la partida mediante informacion post analisis pertinente, ejemplo: "Equity: 65%", "Dato Psicol√≥gico (Rival: FLOJO)". "Acci√≥n Sugerida: RAISE". 

Estados del OCR. (si esta inactivo o no se detecta la ventana explicar por que). Que diga si se detecta la ventana del juego. (se presume que si esta abierto el software esta abierta tambien la ventana de juego, si no se detecta determinar motivo).

Se debe poder seleccionar manualmente la ventana de la mesa de poker para analizar, tambien se debe poder hacer un screenshot a la misma con motivos de prueba y evaluacion, este screenshot debe ser tomado con todas las caracteristicas anti deteccion utilizadas por el OCR. Definir endpoint recomendado.

En caso que algo falle debera existir un boton de registro de errores que al presionarlo guarde un log o screenshots de los errores para su correccion.

Se deben visualizar las lecturas de las cartas con suit symbols del color correspondiente.

Usar icono que se encuentra en la carpeta de los archivos creados nombrado icoRGB.ico

El theme requerido para la GUI esta en: HTP\interface.css







Utilizar Unicode Playing Cards (palos y colores). Mapeo eval7.Card ‚Üí s√≠mbolo Unicode (‚ô†, ‚ô•, ‚ô¶, ‚ô£) + color. Mostrar en GUI.








21. M√≥dulo de captura de imagen "input_handler.py":


El plugin input_handler.py usar√° DXcam por defecto. La l√≥gica de "HDMI" o "OBS" debe ser una configuraci√≥n (config.json), no un m√≥dulo separado que compita. Las principales funciones son las siguientes:


Captura de Escritorio (Desktop Duplication API): En lugar de intentar capturar una ventana espec√≠fica, se puede utilizar la Desktop Duplication API de Windows. Esta API se dise√±√≥ para la duplicaci√≥n de escritorio (ej. para streaming o proyectores) y tiene un nivel de privilegio m√°s alto, a menudo eludiendo las restricciones de captura de ventana individuales, es decir una vez que se obtiene el frame del escritorio, se usa OpenCV/YOLO para recortar solo la parte que corresponde a la ventana del juego (utilizando las coordenadas obtenidas de tu sistema de calibraci√≥n avanzado).



input_handler.py:

Usa dxcam para capturar toda la pantalla con Desktop Duplication API.
Recorta seg√∫n SharedState["window_rect"].
Maneja errores t√≠picos:
Frame None.
Pantalla negra (para usarlo junto con self_check_plugin).

Se debe permitir alternar con los modulos BetterCam y WinCam.


Con los parametros y tecnicas ya mencionados.












22. M√≥dulo OCR Y visi√≥n por computadora en el archivo de OCR advanced_ocr_plugin.py # EasyOCR + Limpieza de texto:

Descripcion de funciones:

‚ÄúLa l√≥gica completa de OCR robusto (preprocesado, smoothing de buffer_ocr, etc.) se implementar√° EXCLUSIVAMENTE en el plugin advanced_ocr_plugin.py. vision_core.py s√≥lo detecta d√≥nde est√°n pot_text, stack_text, bet_text y escribe sus coords en SharedState["detections"].‚Äù

advanced_ocr_plugin.py: leera SharedState["frame"] + bounding boxes OCR de SharedState["detections"] y ah√≠ implementa TODO el preprocesado y smoothing.


Con los parametros y tecnicas ya mencionados.

Usar whitelists, preprocess y filtros para mejorar

El modelo debe ser capaz de distinguir todas las clases y toda la informacion registrada por YOLO.


Debe capturar:

A) Informacion de las cartas (prioridad alta):

Mis cartas (Hole Cards), a veces est√°n parcialmente ocultas o inclinadas.

Cartas Comunitarias (Board): Se debe detectar cu√°ndo aparecen nuevas cartas para disparar una re-evaluaci√≥n del motor.

B) Informaci√≥n Financiera.

El Bote Total (Total Pot), n√∫mero central que indica cu√°nto dinero hay en juego, m√©todo: YOLO detecta la regi√≥n -> OCR lee el n√∫mero..

Apuestas Actuales (Current Bets): las fichas o n√∫meros frente a cada jugador activo en la calle actual (define el precio que debo pagar para ver la siguiente carta).

Stacks de los Jugadores (Fichas): La cantidad total de dinero que tiene cada jugador detr√°s, para calcular el "Stack Efectivo" no se juega igual si el oponente tiene 10 ciegas grandes (All-in probable) que si tiene 100 ciegas grandes.

C) Informaci√≥n de Estado y Posici√≥n (L√≥gica de Juego):

Bot√≥n de Dealer (Dealer Button) el peque√±o disco (usualmente marcado con una "D"). Determina qui√©n habla primero y √∫ltimo. Es vital para los rangos de apertura.

Estado de los Jugadores (Activo/Fold/Ausente): ¬øEl jugador tiene cartas? L√≥gica: Necesito saber contra cu√°ntos oponentes juegas. Un Raise contra 5 jugadores es muy diferente a un Raise contra 1.

Mi Turno (Hero Action): Determinado por la aparici√≥n de los botones de acci√≥n (Fold, Call, Raise) o la barra de tiempo, debe conllevar a un disparador (Trigger) para iniciar el an√°lisis y sugerir la jugada.

Debe calibrarse automaticamente.

Configuracion adicional:


Resumen del Flujo de Datos:

Captura (DXcam): Obtiene la imagen cruda.

YOLO: Dice "Aqu√≠ est√° el Bote", "Aqu√≠ est√° el Dealer", "Aqu√≠ hay un As de Picas".

L√≥gica: Si YOLO ve el bot√≥n de "Tu Turno":

Recorta el √°rea del Bote y Stacks -> OCR lee los valores.

Combina [Cartas] + [Posici√≥n Dealer] + [Ciegas] + [Dinero] .

Env√≠a todo al Motor de Probabilidad.



Ejemplo a mejorar del archivo de OCR advanced_ocr_plugin.py # EasyOCR + Limpieza de texto:


# Historial para suavizado de datos (Smoothing)
# Estructura: 'stack_text_3': [100.0, 100.0, 100.0, 5000.0(Error), 100.0]
buffer_ocr = {} 

# ... DENTRO DEL BUCLE DE DETECCI√ìN ...

    if nombre in OCR_LABELS:
        valor_raw = leer_dinero_robusto(frame, coords)
        
        # ID √∫nico para este objeto (basado en posici√≥n aproximada)
        # Esto sirve para saber que estamos leyendo SIEMPRE el mismo stack
        obj_id = f"{nombre}_{int(coords[0]/50)}_{int(coords[1]/50)}"
        
        if obj_id not in buffer_ocr:
            buffer_ocr[obj_id] = []
            
        # Agregar al buffer (m√°ximo 5 lecturas)
        buffer_ocr[obj_id].append(valor_raw)
        if len(buffer_ocr[obj_id]) > 5:
            buffer_ocr[obj_id].pop(0)
            
        # VALIDACI√ìN HEUR√çSTICA: Usar la MEDIANA
        # La mediana ignora valores locos.
        # Si el buffer es [100, 100, 9999, 100, 100], la media ser√≠a alta, la mediana es 100.
        valor_validado = np.median(buffer_ocr[obj_id])
        
        # Usar 'valor_validado' para tu l√≥gica de juego





# ==========================================
# FUNCIONES AUXILIARES (VISI√ìN Y L√ìGICA)
# ==========================================

def leer_dinero_robusto(frame, coords):
    """Pipeline de OCR: Recorte -> Upscale -> Threshold -> EasyOCR"""
    x1, y1, x2, y2 = map(int, coords)
    h, w = frame.shape[:2]
    x1, y1, x2, y2 = max(0, x1), max(0, y1), min(w, x2), min(h, y2)
    
    recorte = frame[y1:y2, x1:x2]
    if recorte.size == 0: return 0.0

    # Upscaling x3 y Binarizaci√≥n
    img = cv2.resize(recorte, (0,0), fx=3, fy=3, interpolation=cv2.INTER_CUBIC)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # Invertir si es necesario (letras claras fondo oscuro)
    if cv2.countNonZero(thresh) < (thresh.size / 2):
        thresh = cv2.bitwise_not(thresh)

    res = reader.readtext(thresh, allowlist='0123456789.$kKmMBb', detail=0)
    if not res: return 0.0
    
    try:
        txt = res[0].lower().replace(',', '.')
        mult = 1000 if 'k' in txt else (1000000 if 'm' in txt else 1)
        val = float(re.sub(r"[^\d\.]", "", txt)) * mult
        return val
    except:
        return 0.0

def detectar_mesa_y_dealer(puntos_stacks, pos_dealer_btn, w, h):
    """Retorna (Tama√±o Mesa, √çndice del Dealer 0-N)"""
    # 1. Tama√±o (4, 6, 8, 9)
    es_9max = False
    for x, y in puntos_stacks:
        xn, yn = x/w, y/h
        for z in ZONAS_9MAX:
            if z[0] < xn < z[2] and z[1] < yn < z[3]:
                es_9max = True; break
    
    cant = len(puntos_stacks)
    size = 9 if (es_9max or cant > 6) else 6
    
    # 2. Qui√©n es el dealer (Stack m√°s cercano al bot√≥n)
    idx_dealer = -1
    if pos_dealer_btn and puntos_stacks:
        dist_min = float('inf')
        for i, stack in enumerate(puntos_stacks):
            d = math.sqrt((stack[0]-pos_dealer_btn[0])**2 + (stack[1]-pos_dealer_btn[1])**2)
            if d < dist_min:
                dist_min = d
                idx_dealer = i
                
    return size, idx_dealer







23. Cosas adicionales a tener en cuenta:

No analizar la ventana de lobby de software de poker.

La ventana de la mesa usa nombres como "Mesa", "Green", "holdem", "Tournament", "Freeroll", "Ciegas", etc. 






Entonces:

A) Genera por pasos primero el primer archivo del proyecto "HTP.py" teniendo en cuenta todos los parametros y enfocandose en resolver los problemas presentados. Determina cuales plugins se van a utilizar en el comienzo y deja espacio en el codigo por si se quiere agregar alguno, priorizar una eficiente distribucion de plugins. Los codigos de ejemplo mencionados anteriormente pueden tener errores de sintaxis u otros, siempre mejorarlos y adaptarlos para que sean funcionales.
B) Luego te pedire "config.json", luego ".spec") y luego construiremos 1 a 1 los siguientes plugins iniciales en la carpeta \HTP\plugins

input_handler.py           # DXcam / Detecci√≥n de Ventana
vision_core.py             # YOLO + L√≥gica de Mesa (Dealer/Cartas)
advanced_ocr_plugin.py     # EasyOCR + Limpieza de texto
window_detector_plugin.py
main_player_decisions.py   # (que use PreflopBrain + PostflopBrain + PlayerProfile)
self_check_plugin.py       # (autodiagn√≥stico con verificar_vision, check de dependencias, etc.)
blinds_detector.py
errores.py
HTPGUI.py                  # FastAPI + WebSocket 

Luego insertaremos mediante un comando los archivos __init__.py y otros que sean necesarios.

C) Completa las librerias faltantes de las secciones de codigo provistas.
D) Genera instrucciones precisas para su compilacion e instalacion paso a paso sin virtual enviroment.
E) Dime tu opinion directa sobre el software, posibles mejoras, falencias, etc.






